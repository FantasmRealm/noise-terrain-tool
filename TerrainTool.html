<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Godotåœ°å½¢é«˜åº¦å›¾&æ¨¡å‹ç”Ÿæˆå™¨</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #eee;
            border: none;
            font-size: 16px;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            background: #4CAF50;
            color: white;
        }
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        .tab-content.active {
            display: block;
        }
        .controls {
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        input, select, button {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            padding: 12px;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        #canvas-container {
            text-align: center;
            margin-top: 20px;
        }
        canvas {
            border: 1px solid #ddd;
            max-width: 100%;
            height: auto;
        }
        .download-btn {
            background-color: #2196F3;
            margin-top: 10px;
        }
        .download-btn:hover {
            background-color: #0b7dda;
        }
        .tips {
            margin-top: 20px;
            padding: 10px;
            background-color: #e7f3ff;
            border-left: 4px solid #2196F3;
        }
        #image-upload {
            margin: 10px 0;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            text-align: center;
        }
        #model-format {
            margin: 10px 0;
        }
        .loading {
            color: #2196F3;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Godotåœ°å½¢é«˜åº¦å›¾&æ¨¡å‹ç”Ÿæˆå™¨</h1>
        
        <!-- æ ‡ç­¾é¡µ -->
        <div class="tabs">
            <button class="tab active" onclick="openTab('generator')">é«˜åº¦å›¾ç”Ÿæˆ</button>
            <button class="tab" onclick="openTab('modeler')">æ¨¡å‹ç”Ÿæˆï¼ˆè¯†åˆ«é«˜åº¦å›¾ï¼‰</button>
        </div>

        <!-- é«˜åº¦å›¾ç”Ÿæˆæ ‡ç­¾é¡µ -->
        <div id="generator" class="tab-content active">
            <div class="controls">
                <div class="control-group">
                    <label for="width">å›¾ç‰‡å®½åº¦ï¼ˆåƒç´ ï¼‰</label>
                    <input type="number" id="width" value="512" min="64" max="2048">
                </div>
                <div class="control-group">
                    <label for="height">å›¾ç‰‡é«˜åº¦ï¼ˆåƒç´ ï¼‰</label>
                    <input type="number" id="height" value="512" min="64" max="2048">
                </div>
                <div class="control-group">
                    <label for="scale">å™ªæ³¢ç¼©æ”¾ï¼ˆè¶Šå°è¶Šç²¾ç»†ï¼‰</label>
                    <input type="number" id="scale" value="20" min="1" max="100" step="0.5">
                </div>
                <div class="control-group">
                    <label for="octaves">ç»†èŠ‚å±‚æ•°ï¼ˆè¶Šå¤šè¶Šå¤æ‚ï¼‰</label>
                    <input type="number" id="octaves" value="4" min="1" max="8">
                </div>
                <button id="generate-btn">ç”Ÿæˆé«˜åº¦å›¾</button>
            </div>

            <div id="canvas-container">
                <canvas id="heightmap-canvas"></canvas>
                <br>
                <button id="download-heightmap-btn" class="download-btn" style="display: none;">ä¸‹è½½PNGé«˜åº¦å›¾</button>
            </div>
        </div>

        <!-- æ¨¡å‹ç”Ÿæˆæ ‡ç­¾é¡µ -->
        <div id="modeler" class="tab-content">
            <div class="control-group">
                <label>ä¸Šä¼ é«˜åº¦å›¾ï¼ˆé»‘ç™½/ç°åº¦PNGï¼‰</label>
                <div id="image-upload">
                    <input type="file" id="heightmap-upload" accept="image/png,image/jpg,image/jpeg">
                    <p id="upload-status">æœªä¸Šä¼ å›¾ç‰‡</p>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="height-scale">åœ°å½¢é«˜åº¦ç¼©æ”¾ï¼ˆå€¼è¶Šå¤§è¶Šé«˜ï¼‰</label>
                    <input type="number" id="height-scale" value="20" min="1" max="200" step="0.5">
                </div>
                <div class="control-group">
                    <label for="mesh-scale">å¹³é¢ç¼©æ”¾ï¼ˆX/Zè½´ï¼‰</label>
                    <input type="number" id="mesh-scale" value="0.1" min="0.01" max="1" step="0.01">
                </div>
                <div class="control-group">
                    <label for="model-format">å¯¼å‡ºæ¨¡å‹æ ¼å¼</label>
                    <select id="model-format">
                        <option value="obj">OBJï¼ˆé€šç”¨ï¼Œæ¨èï¼‰</option>
                        <option value="glb">GLBï¼ˆGodotä¼˜åŒ–ï¼Œå¸¦æè´¨ï¼‰</option>
                        <option value="stl">STLï¼ˆ3Dæ‰“å°ï¼‰</option>
                    </select>
                </div>
                <button id="generate-model-btn" disabled>ç”Ÿæˆå¹¶ä¸‹è½½3Dæ¨¡å‹</button>
            </div>

            <div id="model-preview-container">
                <canvas id="model-preview-canvas"></canvas>
                <div id="loading-indicator" class="loading" style="display: none;">æ­£åœ¨ç”Ÿæˆæ¨¡å‹ï¼Œè¯·ç¨å€™...</div>
            </div>
        </div>

        <div class="tips">
            <h3>æ ¸å¿ƒè§„åˆ™ & Godotä½¿ç”¨è¯´æ˜</h3>
            <ul>
                <li>âœ… ç™½è‰²åŒºåŸŸï¼ˆç°åº¦255ï¼‰= æœ€é«˜åœ°å½¢ï¼ˆè‰åœ°ç»¿ï¼‰ï¼Œé»‘è‰²åŒºåŸŸï¼ˆç°åº¦0ï¼‰= æœ€ä½åœ°å½¢ï¼ˆåœŸåœ°æ£•ï¼‰</li>
                <li>âœ… ç”Ÿæˆçš„æ¨¡å‹å¯ç›´æ¥æ‹–æ‹½åˆ°Godotåœºæ™¯ï¼ŒMeshInstance3Dä¼šè‡ªåŠ¨è¯†åˆ«</li>
                <li>âœ… æ¨èå°ºå¯¸ï¼š256x256ï¼ˆå¹³è¡¡æ€§èƒ½å’Œç»†èŠ‚ï¼‰ï¼Œé«˜åº¦ç¼©æ”¾20-50ï¼ˆåœ°å½¢èµ·ä¼é€‚ä¸­ï¼‰</li>
                <li>âŒ é¿å…ä½¿ç”¨2048x2048è¶…å¤§å°ºå¯¸ï¼Œä¼šå¯¼è‡´æ¨¡å‹é¢æ•°è¿‡å¤šï¼ˆç™¾ä¸‡çº§ï¼‰ï¼ŒGodotåŠ è½½å¡é¡¿</li>
                <li>ğŸ’¡ GLBæ ¼å¼è‡ªå¸¦æ¸å˜æè´¨ï¼ŒOBJ/STLéœ€åœ¨Godotä¸­æ‰‹åŠ¨æ·»åŠ æè´¨</li>
            </ul>
        </div>
    </div>

    <!-- å¼•å…¥Three.jså’ŒGLBå¯¼å‡ºä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/exporters/GLBExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/utils/BufferGeometryUtils.js"></script>

    <script>
        // æ ‡ç­¾é¡µåˆ‡æ¢
        function openTab(tabName) {
            const tabs = document.getElementsByClassName("tab");
            const tabContents = document.getElementsByClassName("tab-content");
            
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove("active");
                tabContents[i].classList.remove("active");
            }
            
            event.currentTarget.classList.add("active");
            document.getElementById(tabName).classList.add("active");
        }

        // ===================== 1. é«˜åº¦å›¾ç”Ÿæˆæ ¸å¿ƒï¼ˆä¼˜åŒ–å‘½åï¼‰ =====================
        class SimplePerlin {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.p = [];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(Math.random() * 256);
                }
                for (let i = 0; i < 256; i++) {
                    this.p[256 + i] = this.p[i];
                }
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                
                const u = this.fade(x);
                const v = this.fade(y);
                
                const A = this.p[X] + Y;
                const B = this.p[X + 1] + Y;
                
                return this.lerp(v, 
                    this.lerp(u, this.grad(this.p[A], x, y), this.grad(this.p[B], x-1, y)),
                    this.lerp(u, this.grad(this.p[A+1], x, y-1), this.grad(this.p[B+1], x-1, y-1))
                );
            }

            fbm(x, y, octaves = 4) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;
                
                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                
                return total / maxValue;
            }
        }

        // é«˜åº¦å›¾ç”Ÿæˆé€»è¾‘
        const generateBtn = document.getElementById('generate-btn');
        const downloadHeightmapBtn = document.getElementById('download-heightmap-btn');
        const heightmapCanvas = document.getElementById('heightmap-canvas');
        const ctx = heightmapCanvas.getContext('2d');

        function generateHeightmap() {
            const width = parseInt(document.getElementById('width').value) || 512;
            const height = parseInt(document.getElementById('height').value) || 512;
            const scale = parseFloat(document.getElementById('scale').value) || 20;
            const octaves = parseInt(document.getElementById('octaves').value) || 4;

            heightmapCanvas.width = width;
            heightmapCanvas.height = height;

            const perlin = new SimplePerlin();
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // ç”Ÿæˆå™ªæ³¢å€¼ï¼ˆ-1 ~ 1ï¼‰â†’ è½¬æ¢ä¸º0~255ç°åº¦
                    const noiseValue = perlin.fbm(x / scale, y / scale, octaves);
                    const gray = Math.floor(((noiseValue + 1) / 2) * 255);
                    const clampedGray = Math.max(0, Math.min(255, gray));
                    
                    // èµ‹å€¼ç»™åƒç´ ï¼ˆç°åº¦å›¾ï¼šR=G=Bï¼‰
                    const index = (y * width + x) * 4;
                    data[index] = clampedGray;     // R
                    data[index + 1] = clampedGray; // G
                    data[index + 2] = clampedGray; // B
                    data[index + 3] = 255;         // A
                }
            }

            ctx.putImageData(imageData, 0, 0);
            downloadHeightmapBtn.style.display = 'block';
        }

        // ä¼˜åŒ–é«˜åº¦å›¾ä¸‹è½½å‘½åï¼ˆåœ°å½¢å™ªæ³¢å›¾ï¼‰
        function downloadHeightmap() {
            const link = document.createElement('a');
            // ä¿®æ­£å‘½åï¼šåœ°å½¢å™ªæ³¢å›¾ + å°ºå¯¸ + æ—¶é—´æˆ³
            const width = heightmapCanvas.width;
            const height = heightmapCanvas.height;
            link.download = `åœ°å½¢å™ªæ³¢å›¾_${width}x${height}_${Date.now()}.png`;
            link.href = heightmapCanvas.toDataURL('image/png');
            link.click();
        }

        generateBtn.addEventListener('click', generateHeightmap);
        downloadHeightmapBtn.addEventListener('click', downloadHeightmap);
        generateHeightmap(); // åˆå§‹ç”Ÿæˆ

        // ===================== 2. æ¨¡å‹ç”Ÿæˆæ ¸å¿ƒï¼ˆæ·»åŠ æ¸å˜æè´¨ï¼‰ =====================
        const heightmapUpload = document.getElementById('heightmap-upload');
        const uploadStatus = document.getElementById('upload-status');
        const generateModelBtn = document.getElementById('generate-model-btn');
        const modelPreviewCanvas = document.getElementById('model-preview-canvas');
        const loadingIndicator = document.getElementById('loading-indicator');
        let uploadedImage = null;

        // å›¾ç‰‡ä¸Šä¼ å¤„ç†
        heightmapUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                uploadStatus.textContent = 'âŒ è¯·ä¸Šä¼ PNG/JPGæ ¼å¼çš„å›¾ç‰‡ï¼';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    uploadedImage = img;
                    uploadStatus.textContent = `âœ… å·²ä¸Šä¼ ï¼š${file.name} (${img.width}x${img.height})`;
                    generateModelBtn.disabled = false;
                    
                    // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆï¼ˆç¼©æ”¾åˆ°400pxå†…ï¼‰
                    modelPreviewCanvas.width = Math.min(400, img.width);
                    modelPreviewCanvas.height = Math.min(400, img.height);
                    const modelCtx = modelPreviewCanvas.getContext('2d');
                    modelCtx.drawImage(img, 0, 0, modelPreviewCanvas.width, modelPreviewCanvas.height);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // ç”ŸæˆOBJæ¨¡å‹ï¼ˆç™½è‰²=é«˜ï¼Œé»‘è‰²=ä½ï¼‰
        function generateOBJ(width, height, heightData, heightScale, meshScale) {
            let objContent = `# Godot Terrain Heightmap Model\n# White = High (Grass), Black = Low (Dirt)\n`;
            let vertexCount = 0;

            // 1. ç”Ÿæˆé¡¶ç‚¹ï¼ˆVï¼šx, y, zï¼‰
            for (let z = 0; z < height; z++) {
                for (let x = 0; x < width; x++) {
                    const grayValue = heightData[z * width + x]; // 0-255
                    const yHeight = (grayValue / 255) * heightScale; // ç™½è‰²=æœ€é«˜ï¼Œé»‘è‰²=0ï¼ˆå¹³åœ°ï¼‰
                    
                    // å¹³é¢åæ ‡å±…ä¸­ï¼Œç¼©æ”¾é€‚é…Godot
                    const worldX = (x - width/2) * meshScale;
                    const worldZ = (z - height/2) * meshScale;
                    
                    // æ·»åŠ é¡¶ç‚¹ï¼ˆä¿ç•™4ä½å°æ•°ï¼Œç²¾ç®€æ–‡ä»¶ï¼‰
                    objContent += `v ${worldX.toFixed(4)} ${yHeight.toFixed(4)} ${worldZ.toFixed(4)}\n`;
                    vertexCount++;
                }
            }

            // 2. ç”Ÿæˆé¢ï¼ˆFï¼šä¸‰è§’é¢ï¼Œé¡ºæ—¶é’ˆï¼‰
            objContent += `# Faces (Triangles)\n`;
            for (let z = 0; z < height - 1; z++) {
                for (let x = 0; x < width - 1; x++) {
                    // è®¡ç®—å››ä¸ªé¡¶ç‚¹çš„ç´¢å¼•ï¼ˆOBJç´¢å¼•ä»1å¼€å§‹ï¼‰
                    const v1 = z * width + x + 1;
                    const v2 = (z + 1) * width + x + 1;
                    const v3 = (z + 1) * width + (x + 1) + 1;
                    const v4 = z * width + (x + 1) + 1;
                    
                    // ä¸¤ä¸ªä¸‰è§’é¢ç»„æˆä¸€ä¸ªå››è¾¹å½¢ï¼ˆä¿è¯æ³•çº¿æ­£ç¡®ï¼‰
                    objContent += `f ${v1} ${v2} ${v3}\n`;
                    objContent += `f ${v1} ${v3} ${v4}\n`;
                }
            }

            return objContent;
        }

        // ç”ŸæˆSTLæ¨¡å‹
        function generateSTL(width, height, heightData, heightScale, meshScale) {
            let stlContent = `solid GodotTerrain\n# White = High (Grass), Black = Low (Dirt)\n`;

            // è®¡ç®—ä¸‰è§’é¢æ³•çº¿
            function calculateNormal(p1, p2, p3) {
                const v1 = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
                const v2 = { x: p3.x - p1.x, y: p3.y - p1.y, z: p3.z - p1.z };
                // å‰ä¹˜æ±‚æ³•çº¿
                const normal = {
                    x: v1.y * v2.z - v1.z * v2.y,
                    y: v1.z * v2.x - v1.x * v2.z,
                    z: v1.x * v2.y - v1.y * v2.x
                };
                // å½’ä¸€åŒ–
                const len = Math.sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
                return len === 0 ? {x:0,y:1,z:0} : {
                    x: (normal.x/len).toFixed(4),
                    y: (normal.y/len).toFixed(4),
                    z: (normal.z/len).toFixed(4)
                };
            }

            // ç”Ÿæˆä¸‰è§’é¢
            for (let z = 0; z < height - 1; z++) {
                for (let x = 0; x < width - 1; x++) {
                    // è·å–å››ä¸ªé¡¶ç‚¹çš„3Dåæ ‡
                    const getPoint = (px, pz) => {
                        const gray = heightData[pz * width + px];
                        return {
                            x: ((px - width/2) * meshScale).toFixed(4),
                            y: ((gray/255)*heightScale).toFixed(4),
                            z: ((pz - height/2) * meshScale).toFixed(4)
                        };
                    };

                    const p1 = getPoint(x, z);
                    const p2 = getPoint(x, z+1);
                    const p3 = getPoint(x+1, z+1);
                    const p4 = getPoint(x+1, z);

                    // ç¬¬ä¸€ä¸ªä¸‰è§’é¢
                    const n1 = calculateNormal(p1, p2, p3);
                    stlContent += `  facet normal ${n1.x} ${n1.y} ${n1.z}\n`;
                    stlContent += `    outer loop\n`;
                    stlContent += `      vertex ${p1.x} ${p1.y} ${p1.z}\n`;
                    stlContent += `      vertex ${p2.x} ${p2.y} ${p2.z}\n`;
                    stlContent += `      vertex ${p3.x} ${p3.y} ${p3.z}\n`;
                    stlContent += `    endloop\n`;
                    stlContent += `  endfacet\n`;

                    // ç¬¬äºŒä¸ªä¸‰è§’é¢
                    const n2 = calculateNormal(p1, p3, p4);
                    stlContent += `  facet normal ${n2.x} ${n2.y} ${n2.z}\n`;
                    stlContent += `    outer loop\n`;
                    stlContent += `      vertex ${p1.x} ${p1.y} ${p1.z}\n`;
                    stlContent += `      vertex ${p3.x} ${p3.y} ${p3.z}\n`;
                    stlContent += `      vertex ${p4.x} ${p4.y} ${p4.z}\n`;
                    stlContent += `    endloop\n`;
                    stlContent += `  endfacet\n`;
                }
            }

            stlContent += `endsolid GodotTerrain\n`;
            return stlContent;
        }

        // ç”ŸæˆGLBæ¨¡å‹ï¼ˆå¸¦é«˜åº¦æ¸å˜æè´¨ï¼šé«˜å¤„ç»¿/ä½å¤„æ£•ï¼‰
        function generateGLB(width, height, heightData, heightScale, meshScale) {
            return new Promise((resolve) => {
                // åˆ›å»ºå¹³é¢å‡ ä½•ä½“ï¼ˆåˆ†æ®µæ•°=åƒç´ æ•°-1ï¼Œä¿è¯æ¯ä¸ªåƒç´ å¯¹åº”ä¸€ä¸ªé¡¶ç‚¹ï¼‰
                const geometry = new THREE.PlaneGeometry(
                    width * meshScale, 
                    height * meshScale, 
                    width - 1, 
                    height - 1
                );

                // è·å–é¡¶ç‚¹ä½ç½®æ•°ç»„
                const positions = geometry.attributes.position;
                // åˆ›å»ºé¢œè‰²å±æ€§æ•°ç»„
                const colors = [];
                
                // å®šä¹‰æ¸å˜é¢œè‰²ï¼šä½å¤„ï¼ˆé»‘è‰²ï¼‰= åœŸåœ°æ£• #8B4513ï¼Œé«˜å¤„ï¼ˆç™½è‰²ï¼‰= è‰åœ°ç»¿ #4CAF50
                const dirtColor = new THREE.Color(0x8B4513); // åœŸåœ°æ£•
                const grassColor = new THREE.Color(0x4CAF50); // è‰åœ°ç»¿

                // æ ¸å¿ƒï¼šä¿®æ”¹æ¯ä¸ªé¡¶ç‚¹çš„Yé«˜åº¦ + è®¾ç½®æ¸å˜é¢œè‰²
                for (let i = 0; i < positions.count; i++) {
                    // è®¡ç®—å½“å‰é¡¶ç‚¹å¯¹åº”çš„å›¾ç‰‡åƒç´ åæ ‡
                    const x = Math.floor(i % width);
                    const z = Math.floor(i / width);
                    
                    if (z < height && x < width) {
                        const grayValue = heightData[z * width + x];
                        const heightRatio = grayValue / 255; // 0-1çš„é«˜åº¦æ¯”ä¾‹
                        const yHeight = heightRatio * heightScale;
                        
                        // è®¾ç½®é¡¶ç‚¹é«˜åº¦
                        positions.setY(i, yHeight);
                        
                        // è®¡ç®—æ¸å˜é¢œè‰²ï¼šæ ¹æ®é«˜åº¦æ¯”ä¾‹æ··åˆæ£•/ç»¿
                        const vertexColor = new THREE.Color();
                        vertexColor.lerpColors(dirtColor, grassColor, heightRatio);
                        colors.push(vertexColor.r, vertexColor.g, vertexColor.b);
                    }
                }

                // æ·»åŠ é¢œè‰²å±æ€§åˆ°å‡ ä½•ä½“
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.attributes.color.needsUpdate = true;

                // æ›´æ–°å‡ ä½•ä½“æ•°æ®
                positions.needsUpdate = true;
                geometry.computeVertexNormals(); // è®¡ç®—æ³•çº¿ï¼Œä¿è¯å…‰ç…§æ­£ç¡®
                geometry.computeBoundingBox();

                // åˆ›å»ºå¸¦é¡¶ç‚¹é¢œè‰²çš„æè´¨
                const material = new THREE.MeshStandardMaterial({ 
                    vertexColors: true, // å¯ç”¨é¡¶ç‚¹é¢œè‰²
                    roughness: 0.8,      // ç²—ç³™æ„Ÿï¼Œæ›´è´´è¿‘çœŸå®åœ°å½¢
                    metalness: 0.1       // ä½é‡‘å±åº¦
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2; // æ—‹è½¬å¹³é¢ï¼Œè®©Yè½´æœä¸Šï¼ˆé€‚é…Godotåæ ‡ç³»ï¼‰

                // å¯¼å‡ºä¸ºGLB
                const exporter = new THREE.GLBExporter();
                exporter.parse(mesh, function(glbBuffer) {
                    resolve(new Blob([glbBuffer], { type: 'model/gltf-binary' }));
                }, { 
                    binary: true,
                    trs: false,
                    onlyVisible: true
                });
            });
        }

        // ä¸‹è½½æ–‡ä»¶é€šç”¨å‡½æ•°
        function downloadFile(content, fileName, mimeType) {
            const blob = typeof content === 'string' ? new Blob([content], { type: mimeType }) : content;
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            link.click();
            URL.revokeObjectURL(url); // é‡Šæ”¾å†…å­˜
        }

        // ç”Ÿæˆæ¨¡å‹ä¸»å‡½æ•°ï¼ˆä¼˜åŒ–å‘½å+è‡ªåŠ¨ä¸‹è½½ï¼‰
        async function generateAndDownloadModel() {
            if (!uploadedImage) return;
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            loadingIndicator.style.display = 'block';
            generateModelBtn.disabled = true;
            uploadStatus.textContent = 'ğŸ”„ æ­£åœ¨è§£æé«˜åº¦å›¾å¹¶ç”Ÿæˆæ¨¡å‹...';

            try {
                // è·å–å‚æ•°ï¼ˆä¼˜åŒ–é»˜è®¤å€¼ï¼‰
                const heightScale = parseFloat(document.getElementById('height-scale').value) || 20;
                const meshScale = parseFloat(document.getElementById('mesh-scale').value) || 0.1;
                const format = document.getElementById('model-format').value;
                const width = uploadedImage.width;
                const height = uploadedImage.height;

                // 1. ç»˜åˆ¶å›¾ç‰‡åˆ°ä¸´æ—¶ç”»å¸ƒï¼Œæå–ç°åº¦æ•°æ®
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCtx.drawImage(uploadedImage, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, width, height);
                const pixelData = imageData.data;

                // 2. è½¬æ¢ä¸ºç°åº¦æ•°ç»„ï¼ˆ0-255ï¼‰
                const heightData = [];
                for (let i = 0; i < pixelData.length; i += 4) {
                    // ç°åº¦è®¡ç®—å…¬å¼ï¼šR*0.299 + G*0.587 + B*0.114ï¼ˆæ ‡å‡†ç°åº¦è½¬æ¢ï¼‰
                    const gray = Math.floor(pixelData[i]*0.299 + pixelData[i+1]*0.587 + pixelData[i+2]*0.114);
                    heightData.push(gray);
                }

                // 3. æ ¹æ®æ ¼å¼ç”Ÿæˆæ¨¡å‹å¹¶è‡ªåŠ¨ä¸‹è½½ï¼ˆä¼˜åŒ–æ¨¡å‹å‘½åï¼‰
                const timestamp = Date.now();
                let fileName, mimeType, modelContent;

                if (format === 'obj') {
                    fileName = `åœ°å½¢æ¨¡å‹_${width}x${height}_OBJ_${timestamp}.obj`;
                    mimeType = 'text/plain';
                    modelContent = generateOBJ(width, height, heightData, heightScale, meshScale);
                } else if (format === 'stl') {
                    fileName = `åœ°å½¢æ¨¡å‹_${width}x${height}_STL_${timestamp}.stl`;
                    mimeType = 'application/sla';
                    modelContent = generateSTL(width, height, heightData, heightScale, meshScale);
                } else if (format === 'glb') {
                    fileName = `åœ°å½¢æ¨¡å‹_${width}x${height}_GLB_æ¸å˜æè´¨_${timestamp}.glb`;
                    mimeType = 'model/gltf-binary';
                    modelContent = await generateGLB(width, height, heightData, heightScale, meshScale);
                }

                // 4. è‡ªåŠ¨ä¸‹è½½
                downloadFile(modelContent, fileName, mimeType);

                // 5. æ›´æ–°çŠ¶æ€
                uploadStatus.textContent = `âœ… æ¨¡å‹ç”Ÿæˆå¹¶ä¸‹è½½å®Œæˆï¼æ ¼å¼ï¼š${format}ï¼Œé¡¶ç‚¹æ•°ï¼š${width*height}ï¼Œé«˜åº¦ç¼©æ”¾ï¼š${heightScale}`;

            } catch (error) {
                uploadStatus.textContent = `âŒ ç”Ÿæˆå¤±è´¥ï¼š${error.message}ï¼ˆå»ºè®®ä½¿ç”¨256x256å°ºå¯¸é‡è¯•ï¼‰`;
            } finally {
                // éšè—åŠ è½½çŠ¶æ€
                loadingIndicator.style.display = 'none';
                generateModelBtn.disabled = false;
            }
        }

        // ç»‘å®šæ¨¡å‹ç”ŸæˆæŒ‰é’®äº‹ä»¶
        generateModelBtn.addEventListener('click', generateAndDownloadModel);
    </script>
</body>
</html>
